/*
 *  rfg.c
 *
 *  Random-data File Generator
 *  Creates a file of random data.
 *
 *  Used by:
 *  rfg filename size[M,m,G,g]
 *
 */

#include <libgen.h> /* basename() */
#include <stdio.h> /* printf(), fopen(), fwrite(), fclose(), FILE* */
#include <stdlib.h> /* srand(), rand(), EXIT_FAILURE, EXIT_SUCCESS */
#include <time.h> /* time() */
#include <string.h> /* strlen() */
#include <stdbool.h> /* bool, true, false */

#ifdef __linux__
#define PRINTF_ULL "%llu"
#endif

#ifdef __WIN32
#define PRINTF_ULL "%I64u"
#endif

#define VERSION "version: 202111121542"

#define BYTES_IN_MB 1048576
#define BYTES_IN_GB 1073741824

#define TOOL_NAME argv[0]

#define OUTPUT_FILENAME argv[1]
#define OUTPUT_FILENAME_LEN_MAX 260

#define OUTPUT_FILESIZE argv[2]
#define OUTPUT_FILESIZE_MAX (BYTES_IN_GB * 128ULL)

/* minimal and maximal limits of the randomly generated value (excluding) */
#define BYTES_MIN 0x00
#define BYTES_MAX 0xff

/* array of the last generated bytes values */
#define LAST_BYTES_SIZE 64

#define ANIMATION_DELAY 50000

bool last_byte_exists(const unsigned char *last_bytes, const unsigned char byte)
{
    bool result = false;
    if (last_bytes != NULL)
    {
        unsigned char *buffer = (unsigned char*)last_bytes;
        while ((*buffer != 0) && (result == false))
        {
            ((*buffer) == byte) ? (result = true) : (0);
            buffer++;
        }
    }
    return result;
}

int main(int argc, char* argv[])
{
    if (argc != 3) /* TOOL_NAME, OUTPUT_FILENAME, OUTPUT_FILESIZE */
    {
        printf("Random-data File Generator, %s\n\nUsage: %s filename filesize[M,m,G,g]\n", VERSION, basename(TOOL_NAME));
        return EXIT_FAILURE;
    }

    unsigned long long int file_length = 0;
    sscanf(OUTPUT_FILESIZE, PRINTF_ULL, &file_length);

    char size_suffix = OUTPUT_FILESIZE[strlen(OUTPUT_FILESIZE) - 1];
    ((size_suffix == 'M') || (size_suffix == 'm')) ? (file_length *= BYTES_IN_MB) : (0);
    ((size_suffix == 'G') || (size_suffix == 'g')) ? (file_length *= BYTES_IN_GB) : (0);

    if (file_length > OUTPUT_FILESIZE_MAX)
    {
        printf("Error: file size must be up to " PRINTF_ULL, OUTPUT_FILESIZE_MAX);
        return EXIT_FAILURE;
    }

    FILE* fileout = fopen(OUTPUT_FILENAME, "wb");
    if (fileout == NULL)
    {
        perror(OUTPUT_FILENAME);
        return EXIT_FAILURE;
    }

    /* last bytes memory allocation */
    unsigned char *last_bytes = (unsigned char*) malloc(sizeof(unsigned char) * LAST_BYTES_SIZE + 2);
    if (last_bytes == NULL)
    {
        printf("Error: memory not allocated\n");
        fclose(fileout);
        return EXIT_FAILURE;
    }
    memset(last_bytes, 0, LAST_BYTES_SIZE + 2);

    size_t byte_size = sizeof(unsigned char);
    unsigned int last_bytes_idx = 0;
    unsigned int percents = 0;
    unsigned int current_percents = 1;
    unsigned long long int counter = 0;
    unsigned long long int file_length_one_procent = file_length / 100;

    srand(time(NULL));

    printf("%s: 0%%", OUTPUT_FILENAME);

    char animation[] = {'/', '/', '-', '\\', '|'};
    int animation_idx = 1;
    int animation_delay = ANIMATION_DELAY;

    while (file_length > 0)
    {
        /* new random byte generating */
        unsigned char byte = BYTES_MIN;
        while ((byte == BYTES_MIN) || (byte == BYTES_MAX))
        {
            byte = (unsigned char) rand() % BYTES_MAX;
            if (last_byte_exists(last_bytes, byte) == false)
            {
                last_bytes[last_bytes_idx] = byte;
                last_bytes_idx %= LAST_BYTES_SIZE; /* to newbies: increment limit */
                last_bytes_idx++;
            }
            else
            {
                byte = BYTES_MIN;
            }
        }

        /* byte writing */
        if (fwrite(&byte, 1, byte_size, fileout) < byte_size)
        {
            printf("Error: writing failed\n");
            free(last_bytes);
            fclose(fileout);
            return EXIT_FAILURE;
        }

        /* progress show */
        if (counter == file_length_one_procent)
        {
            if (percents == 10)
            {
                printf("%u%%", current_percents * 10);
                current_percents++;
                percents = 0;
            }
            else
            {
                putchar('.');
            }
            percents++;
            counter = 0;
        }
        else
        {
            if (animation_delay == 0)
            {
                printf("%c\b", animation[animation_idx]);
                animation_idx %= 4;
                animation_idx++;
                animation_delay = ANIMATION_DELAY;
            }
            animation_delay--;
        }

        counter++;
        file_length--;
    }

    printf("100%%\n");

    free(last_bytes);
    fclose(fileout);

    return EXIT_SUCCESS;
}
